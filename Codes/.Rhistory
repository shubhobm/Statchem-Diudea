c(round(mean(vector),3), round(sd(vector),3))
}
analyze("est_n100p60q30")
analyze("est1step_n100p60q30")
rm(list=ls())
setwd('d:/Study/My projects/Stratified-mult-GGM/Codes/estimation_outputs/')
analyze = function(list, broken=FALSE, array=NULL){
matrix.list = list()
if(broken){
output = list()
index = 1
for(i in array){
load(paste0(list,"_",i,".Rda"))
output[[index]] = rbind(apply(simplify2array(out.mat), 1:2, mean),
apply(simplify2array(out.mat), 1:2, sd))
index = index+1
}
output = round(apply(simplify2array(output), 1:2, mean),3)
} else{
load(paste0(list,".Rda"))
matrix = matrix(unlist(out.mat), ncol=4, byrow=T)
output =  rbind(round(apply(simplify2array(out.mat), 1:2, mean),3),
round(apply(simplify2array(out.mat), 1:2, sd),3))
}
output
}
analyze.size = function(list, broken=FALSE){
vec.list = list()
if(broken){
for(i in 1:5){
load(paste0(list,"_",i,".Rda"))
vec.list[[i]] = as.numeric(unlist(out.mat))
vector = as.numeric(unlist(vec.list))
}
} else{
load(paste0(list,".Rda"))
vector = as.numeric(unlist(out.mat))
}
c(round(mean(vector),3), round(sd(vector),3))
}
analyze("est_n100p60q30")
analyze("estfull_n100p60q30")
analyze = function(list, broken=FALSE, array=NULL, range=NULL){
matrix.list = list()
if(broken){
output = list()
index = 1
for(i in array){
load(paste0(list,"_",i,".Rda"))
output[[index]] = rbind(apply(simplify2array(out.mat), 1:2, mean),
apply(simplify2array(out.mat), 1:2, sd))
index = index+1
}
output = round(apply(simplify2array(output), 1:2, mean),3)
} else{
load(paste0(list,".Rda"))
matrix = matrix(unlist(out.mat), ncol=4, byrow=T)
if(!is.null(range)){
out.mat = out.mat[range,]
}
output =  rbind(round(apply(simplify2array(out.mat), 1:2, mean),3),
round(apply(simplify2array(out.mat), 1:2, sd),3))
}
output
}
analyze.size = function(list, broken=FALSE){
vec.list = list()
if(broken){
for(i in 1:5){
load(paste0(list,"_",i,".Rda"))
vec.list[[i]] = as.numeric(unlist(out.mat))
vector = as.numeric(unlist(vec.list))
}
} else{
load(paste0(list,".Rda"))
vector = as.numeric(unlist(out.mat))
}
c(round(mean(vector),3), round(sd(vector),3))
}
analyze("est_n100p60q30", range=1:10)
rm(list=ls())
setwd('d:/Study/My projects/Stratified-mult-GGM/Codes/estimation_outputs/')
analyze = function(list, broken=FALSE, array=NULL, range=NULL){
matrix.list = list()
if(broken){
output = list()
index = 1
for(i in array){
load(paste0(list,"_",i,".Rda"))
output[[index]] = rbind(apply(simplify2array(out.mat), 1:2, mean),
apply(simplify2array(out.mat), 1:2, sd))
index = index+1
}
output = round(apply(simplify2array(output), 1:2, mean),3)
} else{
load(paste0(list,".Rda"))
matrix = matrix(unlist(out.mat), ncol=4, byrow=T)
if(!is.null(range)){
out.mat = out.mat[,,range]
}
output =  rbind(round(apply(simplify2array(out.mat), 1:2, mean),3),
round(apply(simplify2array(out.mat), 1:2, sd),3))
}
output
}
analyze.size = function(list, broken=FALSE){
vec.list = list()
if(broken){
for(i in 1:5){
load(paste0(list,"_",i,".Rda"))
vec.list[[i]] = as.numeric(unlist(out.mat))
vector = as.numeric(unlist(vec.list))
}
} else{
load(paste0(list,".Rda"))
vector = as.numeric(unlist(out.mat))
}
c(round(mean(vector),3), round(sd(vector),3))
}
analyze("est_n100p60q30", range=1:10)
analyze = function(list, broken=FALSE, array=NULL, range=NULL){
matrix.list = list()
if(broken){
output = list()
index = 1
for(i in array){
load(paste0(list,"_",i,".Rda"))
output[[index]] = rbind(apply(simplify2array(out.mat), 1:2, mean),
apply(simplify2array(out.mat), 1:2, sd))
index = index+1
}
output = round(apply(simplify2array(output), 1:2, mean),3)
} else{
load(paste0(list,".Rda"))
matrix = matrix(unlist(out.mat), ncol=4, byrow=T)
if(is.null(range)){
range = length(out.mat)
}
output =  rbind(round(apply(simplify2array(out.mat)[,,range], 1:2, mean),3),
round(apply(simplify2array(out.mat)[,,range], 1:2, sd),3))
}
output
}
analyze("est_n100p60q30", range=1:10)
analyze("estfull_n100p60q30")
analyze("estfull_n100p60q30")
analyze("estfull_n100p60q30", range=1:10)
analyze = function(list, broken=FALSE, array=NULL, range=NULL){
matrix.list = list()
if(broken){
output = list()
index = 1
for(i in array){
load(paste0(list,"_",i,".Rda"))
output[[index]] = rbind(apply(simplify2array(out.mat), 1:2, mean),
apply(simplify2array(out.mat), 1:2, sd))
index = index+1
}
output = round(apply(simplify2array(output), 1:2, mean),3)
} else{
load(paste0(list,".Rda"))
if(is.null(range)){
range = length(out.mat)
}
output =  rbind(round(apply(simplify2array(out.mat)[,,range], 1:2, mean),3),
round(apply(simplify2array(out.mat)[,,range], 1:2, sd),3))
}
output
}
analyze("est_n100p60q30", range=1:10)
analyze("estfull_n100p60q30")
analyze = function(list, broken=FALSE, array=NULL, range=NULL){
matrix.list = list()
if(broken){
output = list()
index = 1
for(i in array){
load(paste0(list,"_",i,".Rda"))
output[[index]] = rbind(apply(simplify2array(out.mat), 1:2, mean),
apply(simplify2array(out.mat), 1:2, sd))
index = index+1
}
output = round(apply(simplify2array(output), 1:2, mean),3)
} else{
load(paste0(list,".Rda"))
if(is.null(range)){
range = 1:length(out.mat)
}
output =  rbind(round(apply(simplify2array(out.mat)[,,range], 1:2, mean),3),
round(apply(simplify2array(out.mat)[,,range], 1:2, sd),3))
}
output
}
analyze("est_n100p60q30", range=1:10)
analyze("estfull_n100p60q30")
rm(list=ls())
setwd('d:/Study/My projects/Stratified-mult-GGM/Codes/separate_outputs/')
analyze = function(list, broken=FALSE, array=NULL){
matrix.list = list()
if(broken){
output = list()
index = 1
for(i in array){
load(paste0(list,"_",i,".Rda"))
output[[index]] = rbind(apply(simplify2array(out.mat), 1:2, mean),
apply(simplify2array(out.mat), 1:2, sd))
index = index+1
}
output = round(apply(simplify2array(output), 1:2, mean),3)
} else{
load(paste0(list,".Rda"))
matrix = matrix(unlist(out.mat), ncol=4, byrow=T)
output =  rbind(round(apply(simplify2array(out.mat), 1:2, mean),3),
round(apply(simplify2array(out.mat), 1:2, sd),3))
}
output
}
analyze.size = function(list, broken=FALSE){
vec.list = list()
if(broken){
for(i in 1:5){
load(paste0(list,"_",i,".Rda"))
vec.list[[i]] = as.numeric(unlist(out.mat))
vector = as.numeric(unlist(vec.list))
}
} else{
load(paste0(list,".Rda"))
vector = as.numeric(unlist(out.mat))
}
c(round(mean(vector),3), round(sd(vector),3))
}
analyze("estsep_n100p30q60", broken=T, array=2:3)
analyze("estsep_n100p60q30", broken=T, array=2:3)
rm(list=ls())
setwd('d:/Study/My projects/Stratified-mult-GGM/Codes/separate_outputs/')
analyze = function(list, broken=FALSE, array=NULL){
matrix.list = list()
if(broken){
output = list()
index = 1
for(i in array){
load(paste0(list,"_",i,".Rda"))
output[[index]] = rbind(apply(simplify2array(out.mat), 1:2, mean),
apply(simplify2array(out.mat), 1:2, sd))
index = index+1
}
output = round(apply(simplify2array(output), 1:2, mean),3)
} else{
load(paste0(list,".Rda"))
matrix = matrix(unlist(out.mat), ncol=4, byrow=T)
output =  rbind(round(apply(simplify2array(out.mat), 1:2, mean),3),
round(apply(simplify2array(out.mat), 1:2, sd),3))
}
output
}
analyze.size = function(list, broken=FALSE){
vec.list = list()
if(broken){
for(i in 1:5){
load(paste0(list,"_",i,".Rda"))
vec.list[[i]] = as.numeric(unlist(out.mat))
vector = as.numeric(unlist(vec.list))
}
} else{
load(paste0(list,".Rda"))
vector = as.numeric(unlist(out.mat))
}
c(round(mean(vector),3), round(sd(vector),3))
}
analyze("estsep_n100p30q60", broken=T, array=2:3)
analyze("estsep_n100p60q30", broken=T, array=2:3)
analyze("est_n150p200q200", broken=T, array=2)
analyze("estsep_n150p200q200", broken=T, array=2)
rm(list=ls())
source('RobustQSAR_functions.R')
setwd('D:/Study/My projects/Statchem-Diudea/Codes')
source('RobustQSAR_functions.R')
library(glmnet)
library(ddalpha)
library(pls)
library(ncvreg)
library(randomForest)
library(caret)
# combined descriptors
combined95 = read.csv("../Data/Combined-descriptors-95.csv")
y95 = as.numeric(combined95[,2])
X95 = as.matrix(combined95[,-(1:2)])
# apply robust scaling
delta = 1e-3
spa = spatial.median(X95, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X95, 2, mad)
X95 = as.matrix(scale(X95, mu, sigma.vec))
X95 = X95[,-which(is.na(apply(X95,2,var)))]
df95 = data.frame(cbind(y95, X95))
n = nrow(X95)
p = ncol(X95)
split=1
set.seed(split*12012017)
train = sample(1:n, ceiling(.8*n), replace=F)
ntrain = length(train)
## Ridge regression
mod95.ridge = cv.glmnet(X95[train,], y95[train], alpha=0, nfolds=10)
beta.ridge = as.numeric(coef(mod95.ridge), s="lambda.min")
pred.ridge = cbind(1, X95[-train,]) %*% beta.lasso
get.ridge.preds = function(y95,X95){
get.ridge.preds = function(y95,X95){
# apply robust scaling
delta = 1e-3
spa = spatial.median(X95, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X95, 2, mad)
X95 = as.matrix(scale(X95, mu, sigma.vec))
X95 = X95[,-which(is.na(apply(X95,2,var)))]
df95 = data.frame(cbind(y95, X95))
n = nrow(X95)
p = ncol(X95)
## multiple train-test split and predict
err.vec = rep(0, nsplit)
for(split in 1:nsplit){
set.seed(split*12012017)
train = sample(1:n, ceiling(.8*n), replace=F)
ntrain = length(train)
## Ridge regression
mod95.ridge = cv.glmnet(X95[train,], y95[train], alpha=0, nfolds=10)
beta.ridge = as.numeric(coef(mod95.ridge), s="lambda.min")
pred.ridge = cbind(1, X95[-train,]) %*% beta.ridge
err.vec[split] = sum((y95[-train] - pred.ridge)^2)
cat("Split",split,"done!\n")
}
err.vec
}
err1 = get.ridge.preds(y995, X95)
combined95 = read.csv("../Data/Combined-descriptors-95.csv")
y95 = as.numeric(combined95[,2])
X95 = as.matrix(combined95[,-(1:2)])
err1 = get.ridge.preds(y95, X95)
nsplit = 100
nsplit = 100
combined95 = read.csv("../Data/Combined-descriptors-95.csv")
y95 = as.numeric(combined95[,2])
X95 = as.matrix(combined95[,-(1:2)])
err1 = get.ridge.preds(y95, X95)
err1
load('../Data/lta98.rda')
y95 = lta98$Y[-1]
X95 = as.matrix(with(lta98, cbind(ltaTS,ltaTC,lta3D, ltaQC))[-1,])
err2 = get.ridge.preds(y95, X95)
## Diudea descriptors
diudea95 = read.csv("../Data/Diudea-descriptors-95.csv")
X95 = as.matrix(diudea95)
err3 = get.ridge.preds(y95, X95)
err.mat = cbind(err1, err2, err3)
err.mat
median(err1)
median(err2)
median(err23
median(err3)
median(err3)
plot(mod95.ridge)
?cv.glmnet
get.ridge.preds = function(y95,X95){
# apply robust scaling
delta = 1e-3
spa = spatial.median(X95, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X95, 2, mad)
X95 = as.matrix(scale(X95, mu, sigma.vec))
X95 = X95[,-which(is.na(apply(X95,2,var)))]
df95 = data.frame(cbind(y95, X95))
n = nrow(X95)
p = ncol(X95)
## multiple train-test split and predict
err.vec = rep(0, nsplit)
for(split in 1:nsplit){
set.seed(split*12012017)
train = sample(1:n, ceiling(.8*n), replace=F)
ntrain = length(train)
## Ridge regression
mod95.ridge = cv.glmnet(X95[train,], y95[train], alpha=0, nfolds=10,
lambda=10^seq(3, -2, by = -.1))
beta.ridge = as.numeric(coef(mod95.ridge), s="lambda.min")
pred.ridge = cbind(1, X95[-train,]) %*% beta.ridge
err.vec[split] = sum((y95[-train] - pred.ridge)^2)
cat("Split",split,"done!\n")
}
err.vec
}
nsplit = 100
## Diudea descriptors
diudea95 = read.csv("../Data/Diudea-descriptors-95.csv")
X95 = as.matrix(diudea95)
err3 = get.ridge.preds(y95, X95)
plot(mod95.ridge)
set.seed(split*12012017)
train = sample(1:n, ceiling(.8*n), replace=F)
ntrain = length(train)
## Ridge regression
mod95.ridge = cv.glmnet(X95[train,], y95[train], alpha=0, nfolds=10,
lambda=10^seq(3, -2, by = -.1))
beta.ridge = as.numeric(coef(mod95.ridge), s="lambda.min")
pred.ridge = cbind(1, X95[-train,]) %*% beta.ridge
plot(mod95.ridge)
mod95.ridge = cv.glmnet(X95[train,], y95[train], alpha=0, nfolds=10)
plot(mod95.ridge)
save(err.mat, file="err95RR.Rda")
rm(list=ls())
# setwd('D:/Study/My projects/Statchem-Diudea/Codes')
source('RobustQSAR_functions.R')
library(glmnet)
library(ddalpha)
library(pls)
library(ncvreg)
library(randomForest)
library(caret)
get.ridge.preds = function(y508,X508){
# apply robust scaling
delta = 1e-3
spa = spatial.median(X508, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X508, 2, mad)
X508 = as.matrix(scale(X508, mu, sigma.vec))
X508 = X508[,-which(is.na(apply(X508,2,var)))]
df508 = data.frame(cbind(y508, X508))
n = nrow(X508)
p = ncol(X508)
## multiple train-test split and predict
err.vec = rep(0, nsplit)
for(split in 1:nsplit){
set.seed(split*12012017)
train = sample(1:n, ceiling(.8*n), replace=F)
ntrain = length(train)
## Ridge regression
mod508.ridge = cv.glmnet(X508[train,], y508[train], alpha=0, nfolds=10, family="binomial")
beta.ridge = as.numeric(coef(mod508.ridge), s="lambda.min")
pred.ridge = cbind(1, X508[-train,]) %*% beta.ridge
err.vec[split] = sum((y508[-train] - pred.ridge)^2)
cat("Split",split,"done!\n")
}
err.vec
}
nsplit = 100
combined508 = read.csv("../Data/Combined-descriptors-508.csv")
y508 = as.numeric(combined508[,2])
X508 = as.matrix(combined508[,-(1:2)])
err1 = get.ridge.preds(y508, X508)
err508
err1
get.ridge.preds = function(y508,X508){
# apply robust scaling
delta = 1e-3
spa = spatial.median(X508, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X508, 2, mad)
X508 = as.matrix(scale(X508, mu, sigma.vec))
X508 = X508[,-which(is.na(apply(X508,2,var)))]
df508 = data.frame(cbind(y508, X508))
n = nrow(X508)
p = ncol(X508)
## multiple train-test split and predict
err.vec = rep(0, nsplit)
for(split in 1:nsplit){
set.seed(split*12012017)
train = sample(1:n, ceiling(.8*n), replace=F)
ntrain = length(train)
## Ridge regression
mod508.ridge = cv.glmnet(X508[train,], y508[train], alpha=0, nfolds=10, family="binomial")
beta.ridge = as.numeric(coef(mod508.ridge), s="lambda.min")
pred.ridge = exp(cbind(1, X508[-train,]) %*% beta.ridge)
pred.ridge = pred.ridge/(1+pred.ridge)
err.vec[split] = as.numeric(auc(roc(y508[-train],as.numeric(pred.ridge))))
cat("Split",split,"done!\n")
}
err.vec
}
diudea508 = read.csv("../Data/Diudea-descriptors-508.csv")
X508 = diudea508[,-(1:2)] # remove index and character columns
X508 = X508[,-which(apply(X508, 2, function(x) sum(is.na(x)))>0)] # remove NA columns
X508 = as.matrix(X508)
err3 = get.ridge.preds(y508, X508)
split=1
delta = 1e-3
spa = spatial.median(X508, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X508, 2, mad)
X508 = as.matrix(scale(X508, mu, sigma.vec))
X508 = X508[,-which(is.na(apply(X508,2,var)))]
df508 = data.frame(cbind(y508, X508))
n = nrow(X508)
p = ncol(X508)
set.seed(split*12012017)
train = sample(1:n, ceiling(.8*n), replace=F)
ntrain = length(train)
mod508.ridge = cv.glmnet(X508[train,], y508[train], alpha=0, nfolds=10, family="binomial")
beta.ridge = as.numeric(coef(mod508.ridge), s="lambda.min")
pred.ridge = exp(cbind(1, X508[-train,]) %*% beta.ridge)
pred.ridge = pred.ridge/(1+pred.ridge)
pred.ridge
beta.ridge
pred.ridge = exp(cbind(1, X508[-train,]) %*% beta.ridge)
pred.ridge
?predict.cv.glmnet
pred.ridge = predict(mod508.ridge, X508[-train,]), s="lambda.min")
pred.ridge = predict(mod508.ridge, X508[-train,], s="lambda.min")
pred.ridge
plot(mod508.ridge)
