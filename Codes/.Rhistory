library(parallel)
library(caret)
source('misc_functions.R')
source('simgen.r')
nfamily = 1e2 # number of qqfamilies
## generate X data family-wise
MAF = c(0.2,0.4,0.25,0.4,0.25)
n.block = c(6,4,30,6,4)
p = sum(n.block)
n = nfamily*4
p.causal = 20
## generate two error matrices
Kmat = matrix(c(1,0,.5,.5,
0,1,.5,.5,
.5,.5,1,.5,
.5,.5,.5,1), nrow=4,ncol=4)
mytable = matrix(c(657,20770,309704,
403,1042,9013), nrow=2)
mytable
mytable = matrix(c(657,20770,309704,
403,1042,9013), nrow=2, byrow=T)
plot(mytable[1,], col="red", lwd=2, type='l')
lines(mytable[2,], col="blue", lwd=2)
legend("topleft", c("SGL","LARN"), col=c("blue","red"), lwd=2)
plot(mytable[1,], col="red", lwd=2, type='b')
lines(mytable[2,], col="blue", lwd=2)
legend("topleft", c("SGL","LARN"), col=c("blue","red"), lwd=2)
lines(mytable[2,], col="blue", lwd=2, type='b')
plot(mytable[1,], col="red", lwd=2, type='b')
lines(mytable[2,], col="blue", lwd=2, type='b')
legend("topleft", c("SGL","LARN"), col=c("blue","red"), lwd=2)
require(fda.usc)
X = matrix(rnorm(1e4), ncol=10)
colmeans(X)
colMeans(X)
mdepth.HS(X, colMEans(X))$dep
mdepth.HS(X, colMeans(X))$dep
mdepth.HS(X, colMeans(X))
mdepth.HS(X,X)$dep
hist(mdepth.RP(X,X)$dep)
mdepth.HS(X,matrix(colMeans(X), ncol=1))$dep
mdepth.HS(colMeans(X), X)$dep
mdepth.HS(matrix(colMeans(X), ncol=1), X)$dep
mdepth.HS(matrix(colMeans(X), ncol=10), X)$dep
?aggregate\
?aggregate
?xtabs
?rbind
?regress
require(regress)
?regress
?install.packages
require(caret)
createFolds()
createFolds
loopfun = function(foldnum){
train = which(folds != foldnum)
ftrain = length(train)
train = rep(4*train, rep(4,ftrain)) - rep(c(3,2,1,0), ftrain)
Kron = kronecker(diag(ftrain), Kmat)
ntrain = length(train)
mod = regress(y~.-1, ~Kron, data=df[train,])
select.ind = step1.depth(mod, sdn, adj)
err.fold = sum(y[-train]^2)
#if(length(select.ind) > 0){
err.fold = sum((y[-train] - X[[train, select.ind] %*% mod.beta)^2)
#}
err.fold
}
require(parallel)
detectCores()
getwd()
read.csv("C:/Study/My projects/SNP-selection-twin-studies/gedi5 outputs")
read.csv("C:/Study/My projects/SNP-selection-twin-studies/gedi5 outputs/geneinfo.csv")
gene.info.df = read.csv("C:/Study/My projects/SNP-selection-twin-studies/gedi5 outputs/geneinfo.csv")
names(gene.info.df)
load("C:/Study/My projects/Depth-regression/Codes/all_results_GLt_LARN.Rda")
z = matrix(unlist(lapply(all.results, function(x) x[[5]])))
head(z)
z = matrix(unlist(lapply(all.results, function(x) x[[5]])), ncol=3, byrow=T)
head(z)
colMeans(z)
z = matrix(unlist(lapply(all.results, function(x) x[[4]])), ncol=3, byrow=T)
colMeans(z)
sqrt(colMeans(z))/(18*40)
40*(1+8.5)^20
40*((1+8.5)^20)
40*((1+.085)^20)
40*.085
40*.085*20+40
(40*.085*20+40)/240
(50*.085*20+40)/240
(60*.085*20+40)/240
setwd('c:/Study/My projects/Statchem-Diudea/Codes')
install.packages("ddalpha")
library(ddalpha)
combined95 = read.csv("../Data/Combined-descriptors-95.csv")
y95 = as.numeric(combined95[,2])
X95 = as.matrix(combined95[,-(1:2)])
# apply robust scaling
delta = 1e-3
spa = spatial.median(X95, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X95, 2, mad)
X95 = as.matrix(scale(X95, mu, sigma.vec))
# X95 = as.matrix(scale(X95, mu, scale=F))
which.na = which(is.na(apply(X95,2,var)))
# which.na = which(apply(X95,2,var) < 1e-3)
X95 = X95[,-which.na]
names95 = names(combined95)[-(1:2)][-which.na]
df95 = data.frame(cbind(y95, X95))
n = nrow(X95)
p = ncol(X95)
## Principal Component Analysis
set.seed(04172018)
Xd = X95
depth = depth.projection(X95, X95)
depth = max(depth) - depth
for(i in 1:n)
{
z = sqrt(sum((Xd[i,  ])^2))
if(z > ep)
{
Xd[i,  ] = depth[i] * (Xd[i,  ]  )/z
}
}
svd95 = svd(Xd)
install.packages("ICSNP")
library(ICSNP)
combined95 = read.csv("../Data/Combined-descriptors-95.csv")
y95 = as.numeric(combined95[,2])
X95 = as.matrix(combined95[,-(1:2)])
# apply robust scaling
delta = 1e-3
spa = spatial.median(X95, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X95, 2, mad)
X95 = as.matrix(scale(X95, mu, sigma.vec))
# X95 = as.matrix(scale(X95, mu, scale=F))
which.na = which(is.na(apply(X95,2,var)))
# which.na = which(apply(X95,2,var) < 1e-3)
X95 = X95[,-which.na]
names95 = names(combined95)[-(1:2)][-which.na]
df95 = data.frame(cbind(y95, X95))
n = nrow(X95)
p = ncol(X95)
# setwd('c:/Study/My projects/Statchem-Diudea/Codes')
source('RobustQSAR_functions.R')
spa = spatial.median(X95, delta)
spa
# combined descriptors
combined95 = read.csv("../Data/Combined-descriptors-95.csv")
y95 = as.numeric(combined95[,2])
X95 = as.matrix(combined95[,-(1:2)])
# apply robust scaling
delta = 1e-3
spa = spatial.median(X95, delta)
spa
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X95, 2, mad)
X95 = as.matrix(scale(X95, mu, sigma.vec))
# X95 = as.matrix(scale(X95, mu, scale=F))
which.na = which(is.na(apply(X95,2,var)))
# which.na = which(apply(X95,2,var) < 1e-3)
X95 = X95[,-which.na]
names95 = names(combined95)[-(1:2)][-which.na]
df95 = data.frame(cbind(y95, X95))
n = nrow(X95)
p = ncol(X95)
set.seed(04172018)
Xd = X95
depth = depth.projection(X95, X95)
depth = max(depth) - depth
for(i in 1:n)
{
z = sqrt(sum((Xd[i,  ])^2))
if(z > ep)
{
Xd[i,  ] = depth[i] * (Xd[i,  ]  )/z
}
}
svd95 = svd(Xd)
svd95$d
svd95$d/(sum(svd95$d))
1-cumsum(svd95$d/(sum(svd95$d)))
plot(1-cumsum(svd95$d/(sum(svd95$d)))
, type='l')
# combined descriptors
combined508 = read.csv("../Data/Combined-descriptors-508.csv")
y508 = as.numeric(combined508[,2])
X508 = as.matrix(combined508[,-(1:2)])
# apply robust scaling
delta = 1e-3
spa = spatial.median(X508, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X508, 2, mad)
X508 = as.matrix(scale(X508, mu, sigma.vec))
# X508 = as.matrix(scale(X508, mu, scale=F))
which.na = which(is.na(apply(X508,2,var)))
# which.na = which(apply(X508,2,var) < 1e-3)
X508 = X508[,-which.na]
names508 = names(combined508)[-(1:2)][-which.na]
df508 = data.frame(cbind(y508, X508))
n = nrow(X508)
p = ncol(X508)
## Principal Component Analysis
Xd = X508
depth = depth.projection(X508, X508, seed=04172018)
depth = max(depth) - depth
for(i in 1:n)
{
z = sqrt(sum((Xd[i,  ])^2))
if(z > ep)
{
Xd[i,  ] = depth[i] * (Xd[i,  ]  )/z
}
}
svd508 = svd(Xd)
svd508$d/(sum(svd508$d))
for(i in 1:10){
V1 = names508[order(abs(svd508$v[,i]), decreasing=T)][1:10]
V2 = svd508$v[order(abs(svd508$v[,i]), decreasing=T),1][1:10]
data.frame(cbind(V1,V2))
}
data.frame(cbind(V1,V2))
for(i in 1:10){
V1 = names508[order(abs(svd508$v[,i]), decreasing=T)][1:10]
V2 = svd508$v[order(abs(svd508$v[,i]), decreasing=T),i][1:10]
data.frame(cbind(V1,V2))
}
data.frame(cbind(V1,V2))
cat(data.frame(cbind(V1,round(V2,2))))
for(i in 1:10){
V1 = names508[order(abs(svd508$v[,i]), decreasing=T)][1:10]
V2 = svd508$v[order(abs(svd508$v[,i]), decreasing=T),i][1:10]
cat(data.frame(cbind(V1,round(V2,2))))
}
df.list = list()
svd508 = svd(Xd)
df.list = list()
for(i in 1:10){
V1 = names508[order(abs(svd508$v[,i]), decreasing=T)][1:10]
V2 = svd508$v[order(abs(svd508$v[,i]), decreasing=T),i][1:10]
df.list[[i]] = data.frame(cbind(V1,round(V2,2)))
}
df.list
names(df.list) = paste0("PC",1:10)
df.list
df.list = list()
for(i in 1:10){
V1 = names508[order(abs(svd508$v[,i]), decreasing=T)][1:10]
V2 = svd508$v[order(abs(svd508$v[,i]), decreasing=T),i][1:10]
idf = data.frame(cbind(V1,round(V2,2)))
colnames(idf) = c("Descriptor","Loading")
df.list[[i]] = idf
}
names(df.list) = paste0("PC",1:10)
df.list
svd95 = svd(Xd)
df.list = list()
for(i in 1:10){
V1 = names95[order(abs(svd95$v[,i]), decreasing=T)][1:10]
V2 = svd95$v[order(abs(svd95$v[,i]), decreasing=T),i][1:10]
idf = data.frame(cbind(V1,round(V2,2)))
colnames(idf) = c("Descriptor","Loading")
df.list[[i]] = idf
}
names(df.list) = paste0("PC",1:10)
df.list
##
rm(list=ls())
# setwd('c:/Study/My projects/Statchem-Diudea/Codes')
source('RobustQSAR_functions.R')
library(ddalpha)
library(ICSNP)
# combined descriptors
combined95 = read.csv("../Data/Combined-descriptors-95.csv")
y95 = as.numeric(combined95[,2])
X95 = as.matrix(combined95[,-(1:2)])
# apply robust scaling
delta = 1e-3
spa = spatial.median(X95, delta)
mu = spa$mu
ep = spa$ep
sigma.vec = apply(X95, 2, mad)
X95 = as.matrix(scale(X95, mu, sigma.vec))
# X95 = as.matrix(scale(X95, mu, scale=F))
which.na = which(is.na(apply(X95,2,var)))
# which.na = which(apply(X95,2,var) < 1e-3)
X95 = X95[,-which.na]
names95 = names(combined95)[-(1:2)][-which.na]
df95 = data.frame(cbind(y95, X95))
n = nrow(X95)
p = ncol(X95)
## Principal Component Analysis
set.seed(04172018)
Xd = X95
depth = depth.projection(X95, X95)
depth = max(depth) - depth
for(i in 1:n)
{
z = sqrt(sum((Xd[i,  ])^2))
if(z > ep)
{
Xd[i,  ] = depth[i] * (Xd[i,  ]  )/z
}
}
svd95 = svd(Xd)
df.list = list()
for(i in 1:10){
V1 = names95[order(abs(svd95$v[,i]), decreasing=T)][1:10]
V2 = svd95$v[order(abs(svd95$v[,i]), decreasing=T),i][1:10]
idf = data.frame(cbind(V1,round(V2,2)))
colnames(idf) = c("Descriptor","Loading")
df.list[[i]] = idf
}
names(df.list) = paste0("PC",1:10)
# V1 = names95[order(abs(svd95$v[,1]), decreasing=T)][1:10]
# V2 = svd95$v[order(abs(svd95$v[,1]), decreasing=T),1][1:10]
# data.frame(cbind(V1,round(V2,2)))
#
# V1 = names95[order(abs(svd95$v[,2]), decreasing=T)][1:10]
# V2 = svd95$v[order(abs(svd95$v[,2]), decreasing=T),2][1:10]
# data.frame(cbind(V1,round(V2,2)))
#
# V1 = names95[order(abs(svd95$v[,3]), decreasing=T)][1:10]
# V2 = svd95$v[order(abs(svd95$v[,3]), decreasing=T),3][1:10]
# data.frame(cbind(V1,round(V2,2)))
#
# V1 = names95[order(abs(svd95$v[,4]), decreasing=T)][1:10]
# V2 = svd95$v[order(abs(svd95$v[,4]), decreasing=T),4][1:10]
# data.frame(cbind(V1,round(V2,2)))
df.list
set.seed(04172018)
Xd = X95
depth = depth.projection(X95, X95)
depth = max(depth) - depth
for(i in 1:n)
{
z = sqrt(sum((Xd[i,  ])^2))
if(z > ep)
{
Xd[i,  ] = depth[i] * (Xd[i,  ]  )/z
}
}
svd95 = svd(Xd)
df.list = list()
for(i in 1:10){
V1 = names95[order(abs(svd95$v[,i]), decreasing=T)][1:10]
V2 = svd95$v[order(abs(svd95$v[,i]), decreasing=T),i][1:10]
idf = data.frame(cbind(V1,round(V2,2)))
colnames(idf) = c("Descriptor","Loading")
df.list[[i]] = idf
}
names(df.list) = paste0("PC",1:10)
df.list[[1]]
set.seed(04172018)
Xd = X95
depth = depth.projection(X95, X95)
depth = max(depth) - depth
for(i in 1:n)
{
z = sqrt(sum((Xd[i,  ])^2))
if(z > ep)
{
Xd[i,  ] = depth[i] * (Xd[i,  ]  )/z
}
}
svd95 = svd(Xd)
df.list = list()
for(i in 1:10){
V1 = names95[order(abs(svd95$v[,i]), decreasing=T)][1:10]
V2 = svd95$v[order(abs(svd95$v[,i]), decreasing=T),i][1:10]
idf = data.frame(cbind(V1,round(V2,2)))
colnames(idf) = c("Descriptor","Loading")
df.list[[i]] = idf
}
names(df.list) = paste0("PC",1:10)
df.list[[1]]
df.list
